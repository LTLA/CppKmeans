<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>kmeans: kmeans::Reinitialize&lt; DATA_t, CLUSTER_t, INDEX_t &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">kmeans
   </div>
   <div id="projectbrief">A C++ library for k-means</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>kmeans</b></li><li class="navelem"><a class="el" href="classkmeans_1_1Reinitialize.html">Reinitialize</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classkmeans_1_1Reinitialize-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">kmeans::Reinitialize&lt; DATA_t, CLUSTER_t, INDEX_t &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classkmeans_1_1Reinitialize.html" title="Reinitialize from an existing set of clusters.">Reinitialize</a> from an existing set of clusters.  
 <a href="classkmeans_1_1Reinitialize.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Reinitialize_8hpp_source.html">Reinitialize.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for kmeans::Reinitialize&lt; DATA_t, CLUSTER_t, INDEX_t &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classkmeans_1_1Reinitialize__inherit__graph.png" border="0" usemap="#akmeans_1_1Reinitialize_3_01DATA__t_00_01CLUSTER__t_00_01INDEX__t_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="akmeans_1_1Reinitialize_3_01DATA__t_00_01CLUSTER__t_00_01INDEX__t_01_4_inherit__map" id="akmeans_1_1Reinitialize_3_01DATA__t_00_01CLUSTER__t_00_01INDEX__t_01_4_inherit__map">
<area shape="rect" title="Reinitialize from an existing set of clusters." alt="" coords="5,95,168,151"/>
<area shape="rect" href="classkmeans_1_1Initialize.html" title=" " alt="" coords="25,5,149,47"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for kmeans::Reinitialize&lt; DATA_t, CLUSTER_t, INDEX_t &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classkmeans_1_1Reinitialize__coll__graph.png" border="0" usemap="#akmeans_1_1Reinitialize_3_01DATA__t_00_01CLUSTER__t_00_01INDEX__t_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="akmeans_1_1Reinitialize_3_01DATA__t_00_01CLUSTER__t_00_01INDEX__t_01_4_coll__map" id="akmeans_1_1Reinitialize_3_01DATA__t_00_01CLUSTER__t_00_01INDEX__t_01_4_coll__map">
<area shape="rect" title="Reinitialize from an existing set of clusters." alt="" coords="5,95,168,151"/>
<area shape="rect" href="classkmeans_1_1Initialize.html" title=" " alt="" coords="25,5,149,47"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkmeans_1_1Reinitialize_1_1Defaults.html">Defaults</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default parameters.  <a href="structkmeans_1_1Reinitialize_1_1Defaults.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aaa58036a305a096e0d699cd3703b7b29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkmeans_1_1Reinitialize.html">Reinitialize</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkmeans_1_1Reinitialize.html#aaa58036a305a096e0d699cd3703b7b29">set_seed</a> (uint64_t s=<a class="el" href="structkmeans_1_1Reinitialize_1_1Defaults.html#adc7a1053e24b4b7f1c128209a81f1901">Defaults::seed</a>)</td></tr>
<tr class="separator:aaa58036a305a096e0d699cd3703b7b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e13953afab10258813e60712b5f276a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkmeans_1_1Reinitialize.html">Reinitialize</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkmeans_1_1Reinitialize.html#a3e13953afab10258813e60712b5f276a">set_recompute_clusters</a> (bool r=<a class="el" href="structkmeans_1_1Reinitialize_1_1Defaults.html#af89037abde3b85d9a05b7ceb3dabe91a">Defaults::recompute_clusters</a>)</td></tr>
<tr class="separator:a3e13953afab10258813e60712b5f276a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a6222e587f594135d81b8e69f3680fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkmeans_1_1Reinitialize.html">Reinitialize</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkmeans_1_1Reinitialize.html#a0a6222e587f594135d81b8e69f3680fc">set_iterations</a> (int i=<a class="el" href="structkmeans_1_1Reinitialize_1_1Defaults.html#a246252eb9e3b56b3daa80e043ef6426c">Defaults::iterations</a>)</td></tr>
<tr class="separator:a0a6222e587f594135d81b8e69f3680fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a661d289c4dab08f44ca3469e12cf00"><td class="memItemLeft" align="right" valign="top">CLUSTER_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkmeans_1_1Reinitialize.html#a8a661d289c4dab08f44ca3469e12cf00">run</a> (int ndim, INDEX_t nobs, const DATA_t *data, CLUSTER_t ncenters, DATA_t *centers, CLUSTER_t *clusters)</td></tr>
<tr class="separator:a8a661d289c4dab08f44ca3469e12cf00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classkmeans_1_1Initialize"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classkmeans_1_1Initialize')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classkmeans_1_1Initialize.html">kmeans::Initialize&lt; double, int, int &gt;</a></td></tr>
<tr class="memitem:a7511f915476cf88fbb314bb984582e0c inherit pub_methods_classkmeans_1_1Initialize"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkmeans_1_1Initialize.html#a7511f915476cf88fbb314bb984582e0c">run</a> (int ndim, int nobs, const double *data, int ncenters, double *centers, int *clusters)=0</td></tr>
<tr class="separator:a7511f915476cf88fbb314bb984582e0c inherit pub_methods_classkmeans_1_1Initialize"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename DATA_t = double, typename CLUSTER_t = int, typename INDEX_t = int&gt;<br />
class kmeans::Reinitialize&lt; DATA_t, CLUSTER_t, INDEX_t &gt;</div><p ><a class="el" href="classkmeans_1_1Reinitialize.html" title="Reinitialize from an existing set of clusters.">Reinitialize</a> from an existing set of clusters. </p>
<p >Imagine that we have a high-quality clustering of a dataset that we wish to update with more observations. The goal is to create a new set of clusters that (i) re-uses information from the existing "good" clustering for the previous observations while (ii) accommodating distinct clusters that are unique to the set of new observations. We cannot simply rely on the usual k-means iterations to create a new cluster as the bulk of previous observations discourage large movements of the centers. On the other hand, rerunning the k-means from scratch will discard all information from the existing clustering, possibly reducing the solution quality - especially if the previous clustering was already finely optimized, e.g., via restarts or high iteration counts.</p>
<p >This class implements a reinitialization strategy for an existing k-means clustering after adding new observations. We remove each cluster center in turn and use a <b>kmeans++</b> approach to randomly propose a new cluster center. Sampling probabilities for all observations are weighted by the distances from the other (non-removed) centers. If the proposed cluster center achieves a lower within-cluster-sum-squares (WCSS) than the clustering before removal of the previous center, then the update is accepted and the proposed center becomes the new cluster center. This is repeated for each center and the updated set of cluster centers is reported for further refinement with, e.g., <code><a class="el" href="classkmeans_1_1HartiganWong.html" title="Implements the Hartigan-Wong algorithm for k-means clustering.">HartiganWong</a></code> or <code><a class="el" href="classkmeans_1_1Lloyd.html" title="Implements the Lloyd algorithm for k-means clustering.">Lloyd</a></code>.</p>
<p >Our strategy favors the preservation of existing clusters if there are no better arrangements. However, it can still respond to the presence of new clusters by discarding an existing center if the distance (and thus sampling probability) is large enough. We can reduce the strength of this preference for preservation by repeating the sampling across several iterations, increasing the chance of finding an alternative center with a lower WCSS.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DATA_t</td><td>Floating-point type for the data and centroids. </td></tr>
    <tr><td class="paramname">CLUSTER_t</td><td>Integer type for the cluster assignments. </td></tr>
    <tr><td class="paramname">INDEX_t</td><td>Integer type for the observation index. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a8a661d289c4dab08f44ca3469e12cf00" name="a8a661d289c4dab08f44ca3469e12cf00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a661d289c4dab08f44ca3469e12cf00">&#9670;&nbsp;</a></span>run()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DATA_t  = double, typename CLUSTER_t  = int, typename INDEX_t  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CLUSTER_t <a class="el" href="classkmeans_1_1Reinitialize.html">kmeans::Reinitialize</a>&lt; DATA_t, CLUSTER_t, INDEX_t &gt;::run </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ndim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INDEX_t&#160;</td>
          <td class="paramname"><em>nobs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DATA_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CLUSTER_t&#160;</td>
          <td class="paramname"><em>ncenters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DATA_t *&#160;</td>
          <td class="paramname"><em>centers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CLUSTER_t *&#160;</td>
          <td class="paramname"><em>clusters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ndim</td><td>Number of dimensions. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nobs</td><td>Number of observations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to a <code>ndim</code>-by-<code>nobs</code> array where columns are observations and rows are dimensions. Data should be stored in column-major order. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ncenters</td><td>Number of cluster centers. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">centers</td><td>Pointer to a <code>ndim</code>-by-<code>ncenters</code> array where columns are cluster centers and rows are dimensions. On input, this should contain the previous centroid locations for each cluster. Data should be stored in column-major order. On output, this will contain the reinitialized centroid locations for each cluster. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">clusters</td><td>Pointer to an array of length <code>nobs</code>. On input, this should contain the identity of the closest cluster if <code><a class="el" href="classkmeans_1_1Reinitialize.html#a3e13953afab10258813e60712b5f276a">set_recompute_clusters()</a></code> is set to <code>false</code>; otherwise the input values are ignored. On output, this will contain the (0-indexed) cluster assignment for each observation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>centers</code> and <code>clusters</code> are filled with the new centers and cluster assignments. The number of cluster centers is returned. </dd></dl>

</div>
</div>
<a id="a0a6222e587f594135d81b8e69f3680fc" name="a0a6222e587f594135d81b8e69f3680fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a6222e587f594135d81b8e69f3680fc">&#9670;&nbsp;</a></span>set_iterations()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DATA_t  = double, typename CLUSTER_t  = int, typename INDEX_t  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkmeans_1_1Reinitialize.html">Reinitialize</a> &amp; <a class="el" href="classkmeans_1_1Reinitialize.html">kmeans::Reinitialize</a>&lt; DATA_t, CLUSTER_t, INDEX_t &gt;::set_iterations </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em> = <code><a class="el" href="structkmeans_1_1Reinitialize_1_1Defaults.html#a246252eb9e3b56b3daa80e043ef6426c">Defaults::iterations</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Number of iterations to attempt to find a new center with a lower WCSS than the previous clustering. Larger values increase the likelihood that the cluster centers will be changed during reinitialization.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classkmeans_1_1Reinitialize.html" title="Reinitialize from an existing set of clusters.">Reinitialize</a></code> object. </dd></dl>

</div>
</div>
<a id="a3e13953afab10258813e60712b5f276a" name="a3e13953afab10258813e60712b5f276a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e13953afab10258813e60712b5f276a">&#9670;&nbsp;</a></span>set_recompute_clusters()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DATA_t  = double, typename CLUSTER_t  = int, typename INDEX_t  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkmeans_1_1Reinitialize.html">Reinitialize</a> &amp; <a class="el" href="classkmeans_1_1Reinitialize.html">kmeans::Reinitialize</a>&lt; DATA_t, CLUSTER_t, INDEX_t &gt;::set_recompute_clusters </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>r</em> = <code><a class="el" href="structkmeans_1_1Reinitialize_1_1Defaults.html#af89037abde3b85d9a05b7ceb3dabe91a">Defaults::recompute_clusters</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Whether to compute the closest cluster for each observation on input. If <code>false</code>, we assume that the identity of the closest cluster is already provided in the <code>clusters</code> array in <code><a class="el" href="classkmeans_1_1Reinitialize.html#a8a661d289c4dab08f44ca3469e12cf00">run()</a></code>. This can avoid a redundant search if the cluster is already known, e.g., from previous k-means iterations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classkmeans_1_1Reinitialize.html" title="Reinitialize from an existing set of clusters.">Reinitialize</a></code> object. </dd></dl>

</div>
</div>
<a id="aaa58036a305a096e0d699cd3703b7b29" name="aaa58036a305a096e0d699cd3703b7b29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa58036a305a096e0d699cd3703b7b29">&#9670;&nbsp;</a></span>set_seed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DATA_t  = double, typename CLUSTER_t  = int, typename INDEX_t  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkmeans_1_1Reinitialize.html">Reinitialize</a> &amp; <a class="el" href="classkmeans_1_1Reinitialize.html">kmeans::Reinitialize</a>&lt; DATA_t, CLUSTER_t, INDEX_t &gt;::set_seed </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>s</em> = <code><a class="el" href="structkmeans_1_1Reinitialize_1_1Defaults.html#adc7a1053e24b4b7f1c128209a81f1901">Defaults::seed</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Random seed for the PRNG.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classkmeans_1_1Reinitialize.html" title="Reinitialize from an existing set of clusters.">Reinitialize</a></code> object. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>kmeans/<a class="el" href="Reinitialize_8hpp_source.html">Reinitialize.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
