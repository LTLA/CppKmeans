#ifndef KMEANS_MATRIX_HPP
#define KMEANS_MATRIX_HPP

/**
 * @file Matrix.hpp
 * @brief Interface for matrix inputs.
 */

namespace kmeans {

/**
 * @brief Extractor for accessing random observations.
 *
 * This is typically generated by `Matrix::new_random_extractor()`.
 * It can be assumed that the lifetime of each extractor will not exceed that of its parent `Matrix`.
 *
 * @tparam Index_ Integer type for the observation indices.
 * @tparam Data_ Numeric type for the data.
 */
template<typename Index_, typename Data_>
class RandomAccessExtractor {
public:
    /**
     * @cond
     */
    RandomAccessExtractor() = default;
    RandomAccessExtractor(const RandomAccessExtractor&) = default;
    RandomAccessExtractor(RandomAccessExtractor&&) = default;
    RandomAccessExtractor& operator=(const RandomAccessExtractor&) = default;
    RandomAccessExtractor& operator=(RandomAccessExtractor&&) = default;
    virtual ~RandomAccessExtractor() = default;
    /**
     * @endcond
     */

    /**
     * @param i Index of the observation.
     * @return Pointer to an array of length equal to `Matrix::num_dimensions()`, containing the coordinates for observation `i`.
     *
     * This will only be called within a single thread and may modify internal data members of a `RandomAccessExtractor` subclass. 
     */
    const Data_* get_observation(Index_ i) = 0;
};

/**
 * @brief Extractor for accessing consecutive observations.
 *
 * This is typically generated by `Matrix::new_consecutive_extractor()`.
 * It can be assumed that the lifetime of each extractor will not exceed that of its parent `Matrix`.
 *
 * @tparam Index_ Integer type for the observation indices.
 * @tparam Data_ Numeric type for the data.
 */
template<typename Index_, typename Data_>
class ConsecutiveAccessExtractor {
public:
    /**
     * @cond
     */
    ConsecutiveAccessExtractor() = default;
    ConsecutiveAccessExtractor(const ConsecutiveAccessExtractor&) = default;
    ConsecutiveAccessExtractor(ConsecutiveAccessExtractor&&) = default;
    ConsecutiveAccessExtractor& operator=(const ConsecutiveAccessExtractor&) = default;
    ConsecutiveAccessExtractor& operator=(ConsecutiveAccessExtractor&&) = default;
    virtual ~ConsecutiveAccessExtractor() = default;
    /**
     * @endcond
     */

    /**
     * @return Pointer to an array of length equal to `Matrix::num_dimensions()`, containing the coordinates for the next observation.
     *
     * The first call to this method should return the coordinates of the `start` observation from `Matrix::new_consecutive_extractor()`.
     * The next call should return `start + 1`, etc. until a maximum of `length` calls have been performed.
     *
     * This method will only be called within a single thread and may modify internal data members of a `ConsecutiveAccessExtractor` subclass. 
     */
    const Data_* get_observation() = 0;
};

/**
 * @brief Extractor for accessing indexed observations.
 *
 * This is typically generated by `Matrix::new_indexed_extractor()`.
 * It can be assumed that the lifetime of each extractor will not exceed that of its parent `Matrix`.
 *
 * @tparam Index_ Integer type for the observation indices.
 * @tparam Data_ Numeric type for the data.
 */
template<typename Index_, typename Data_>
class IndexedAccessExtractor {
    /**
     * @cond
     */
    IndexedAccessExtractor() = default;
    IndexedAccessExtractor(const IndexedAccessExtractor&) = default;
    IndexedAccessExtractor(IndexedAccessExtractor&&) = default;
    IndexedAccessExtractor& operator=(const IndexedAccessExtractor&) = default;
    IndexedAccessExtractor& operator=(IndexedAccessExtractor&&) = default;
    virtual ~IndexedAccessExtractor() = default;
    /**
     * @endcond
     */

    /**
     * @return Pointer to an array of length equal to `Matrix::num_dimensions()`, containing the coordinates for the next observation.
     *
     * The first call to this method should return the coordinates of the `sequence[0]` observation from `Matrix::new_consecutive_extractor()`.
     * The next call should return `sequence[1]`, etc. until a maximum of `length` calls have been performed.
     *
     * This method will only be called within a single thread and may modify internal data members of a `ConsecutiveAccessExtractor` subclass. 
     */
    const Data_* get_observation() = 0;
};

/**
 * @brief Interface for matrix data.
 *
 * This defines the expectations for a matrix of observation-level data to be used in `Initialize::run()` and `Refine::run()`.
 * Each matrix should support extraction of the vector of coordinates for each observation.
 *
 * @tparam Index_ Integer type for the observation indices.
 * @tparam Data_ Numeric type for the data.
 */
template<typename Index_, typename Data_>
class Matrix {
public:
    /**
     * @cond
     */
    Matrix() = default;
    Matrix(const Matrix&) = default;
    Matrix(Matrix&&) = default;
    Matrix& operator=(const Matrix&) = default;
    Matrix& operator=(Matrix&&) = default;
    virtual ~Matrix() = default;
    /**
     * @endcond
     */

public:
    /**
     * @return Number of observations.
     */
    virtual Index_ num_observations() const = 0;

    /**
     * @return Number of dimensions.
     */
    virtual size_t num_dimensions() const = 0;

public:
    /**
     * @return A new random-access extractor.
     */
    std::unique_ptr<RandomAccessExtractor<Index_, Data_> > new_extractor() const = 0;

    /**
     * @param start Start of the contiguous block of observations to be accessed consecutively.
     * @param length Length of the contiguous block of observations to be accessed consecutively.
     * @return A new consecutive-access extractor.
     */
    std::unique_ptr<RandomAccessExtractor<Index_, Data_> > new_extractor(Index_ start, Index_ length) const = 0;

    /**
     * @param[in] sequence Pointer to an array of sorted and unique indices of observations, to be accessed in the provided order.
     * It is assumed that the vector will not be deallocated before the destruction of the returned `IndexedAccessWorkspace`.
     * @param length Number of observations in `sequence`.
     * @return A new indexed-access extractor.
     */
    std::unique_ptr<IndexedAccessExtractor<Index_, Data_> > new_extractor(const Index_* sequence, size_t length) const = 0;

};

/**
 * @cond
 */
template<class Matrix_>
using Index = decltype(std::declval<Matrix_>().num_observations());
/**
 * @endcond
 */
}

#endif
